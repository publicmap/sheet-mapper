<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sheet Mapper</title>
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.7.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.7.0/mapbox-gl.css' rel='stylesheet' />
    <script src='https://unpkg.com/papaparse@5.3.0/papaparse.min.js'></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>

    <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.3/mapbox-gl-geocoder.min.js'></script>
    <link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.3/mapbox-gl-geocoder.css' type='text/css' />
    
    <!-- Generate legend from Mapbox styles https://github.com/watergis/mapbox-gl-legend -->
    <link href='https://watergis.github.io/mapbox-gl-legend/mapbox-gl-legend.css' rel='stylesheet' />
<script src="https://watergis.github.io/mapbox-gl-legend/mapbox-gl-legend.js"></script>

    <style>
        body { margin: 0; padding: 0; }
        #map { position: relative; height: calc(100vh - 120px); width: 100%; }
        #center-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1;
        }
    </style>
</head>
<body class="bg-gray-100">
    <!-- Header -->
    <header class="bg-white shadow-md p-4">
        <div class="container mx-auto">
            <!-- Sheet button row -->
            <div class="mb-4">
                <a id="viewSheetData" href="#" target="_blank" class="inline-block px-4 py-2 bg-blue-500 text-white font-bold rounded hover:bg-blue-600">
                    Open Spreadsheet
                    <svg class="inline-block w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
                    </svg>
                </a>
            </div>
            <!-- Filters row -->
            <div id="filterContainer" class="flex flex-wrap items-center gap-2">
                <!-- Filters will be dynamically added here -->
            </div>
        </div>
    </header>

    <!-- Main content -->
    <div class="container mx-auto flex">
        <!-- Sidebar -->
        <div id="sidebar" class="w-1/4 bg-white p-4 overflow-y-auto h-[calc(100vh-120px)]"></div>
        <!-- Map container -->
        <div class="w-3/4">
            <div id="map">
                <div id="center-marker">
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="10" cy="10" r="8" stroke="black" stroke-width="2"/>
                        <circle cx="10" cy="10" r="2" fill="black"/>
                    </svg>
                </div>
            </div>
        </div>
    </div>

    <script>
        mapboxgl.accessToken = 'pk.eyJ1IjoicGxhbmVtYWQiLCJhIjoiY2x2MzZwbGRyMGdheDJtbXVwdDA4aDNyaCJ9.nbvz6aNGQo68xa4NtWH26A';
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/planemad/clzsr0s3c00f701pihaefhc37',
            center: [73.8567, 18.5204],
            zoom: 5,
            hash: true
        });

        // Add geocoder control
        const geocoder = new MapboxGeocoder({
            accessToken: mapboxgl.accessToken,
            mapboxgl: mapboxgl
        });
        map.addControl(geocoder);

        // Add geolocate control
        const geolocate = new mapboxgl.GeolocateControl({
            positionOptions: {
                enableHighAccuracy: true
            },
            trackUserLocation: true
        });
        map.addControl(geolocate, 'top-right');

        const urlParams = new URLSearchParams(window.location.search);
        const sheetId = urlParams.get('sheetId');

        if (!sheetId) {
            console.error('No sheet ID provided in URL parameters');
        } else {
            const sheetUrl = `https://docs.google.com/spreadsheets/d/e/${sheetId}/pub?single=true&output=csv`;
            const viewSheetDataButton = document.getElementById('viewSheetData');
            viewSheetDataButton.href = `https://docs.google.com/spreadsheets/d/e/${sheetId}/pubhtml`;

            map.on('load', () => {
                Papa.parse(sheetUrl, {
                    download: true,
                    header: true,
                    complete: function(results) {
                        const data = results.data.filter(row => row.Latitude && row.Longitude);
                        console.log("Sheet CSV", data);

                        const validRows = [];
                        const invalidRows = [];

                        // Function to detect field type
                        function detectFieldType(value) {
                            if (!isNaN(parseFloat(value))) return 'number';
                            if (value.toLowerCase() === 'true' || value.toLowerCase() === 'false') return 'boolean';
                            return 'string';
                        }

                        // Detect field types
                        const fieldTypes = {};
                        if (data.length > 0) {
                            Object.keys(data[0]).forEach(key => {
                                fieldTypes[key] = detectFieldType(data[0][key]);
                            });
                        }

                        data.forEach((row, index) => {
                            const lon = parseFloat(row.Longitude);
                            const lat = parseFloat(row.Latitude);
                            if (!isNaN(lon) && !isNaN(lat) && 
                                lon >= -180 && lon <= 180 && 
                                lat >= -90 && lat <= 90) {
                                // Convert fields based on detected types
                                Object.keys(row).forEach(key => {
                                    switch (fieldTypes[key]) {
                                        case 'number':
                                            row[key] = parseFloat(row[key]);
                                            break;
                                        case 'date':
                                            row[key] = new Date(row[key]);
                                            break;
                                        case 'boolean':
                                            row[key] = row[key].toLowerCase() === 'true';
                                            break;
                                    }
                                });
                                // Add row_number field
                                row.row_number = index + 2; // Start from 2 to match Google Sheet row
                                validRows.push(row);
                            } else {
                                invalidRows.push(row);
                            }
                        });

                        console.log("Field types:", fieldTypes);
                        console.log("Invalid rows:", invalidRows);

                        const geojson = {
                            type: 'FeatureCollection',
                            features: validRows.map(row => ({
                                type: 'Feature',
                                geometry: {
                                    type: 'Point',
                                    coordinates: [parseFloat(row.Longitude), parseFloat(row.Latitude)]
                                },
                                properties: row
                            }))
                        };

                        // Add a geojson data source to the map and generate unique ids for each feature
                        // The ids are used to link the features to the sidebar items
                        map.addSource('deals', {
                            type: 'geojson',
                            data: geojson,
                            promoteId: 'row_number'
                        });
                        // Add a layer to the map to render the point features as circles
                        map.addLayer({
                            id: 'deals',
                            type: 'circle',
                            source: 'deals',
                            paint: {
                                'circle-radius': [
                                    'interpolate',
                                    ['linear'],
                                    ['zoom'],
                                    10, ['case', ['has', 'circle-radius'], ['to-number', ['get', 'circle-radius']], 3],
                                    16, ['*', 2, ['case', ['has', 'circle-radius'], ['to-number', ['get', 'circle-radius']], 3]]
                                ],
                                'circle-color': [
                                    'case',
                                    ['has', 'circle-color'],
                                    ['get', 'circle-color'],
                                    'grey'
                                ],
                                'circle-stroke-width': [
                                    'case',
                                    ['boolean', ['feature-state', 'hover'], false],
                                    10,
                                    2
                                ],
                                'circle-stroke-color': [
                                    'case',
                                    ['boolean', ['feature-state', 'hover'], false],
                                    '#000000',
                                    '#ffffff'
                                ],
                                'circle-opacity': 1
                            }
                        }, 'waterway-label');

                        // Add a transition for the circle-stroke-width
                        map.setPaintProperty('deals', 'circle-stroke-opacity-transition', {
                            duration: 10000,
                            delay: 1000
                        });

                        function updateSidebar() {
                            const bounds = map.getBounds();
                            let visibleFeatures;
                            
                            // Get the map center as the reference point
                            const mapCenter = map.getCenter();
                            const origin = turf.point([mapCenter.lng, mapCenter.lat]);

                            // Check if the source is loaded
                            const source = map.getSource('deals');
                            if (source && source.loaded()) {
                                // Use querySourceFeatures for live updates
                                visibleFeatures = map.querySourceFeatures('deals', {
                                    filter: ['all',
                                        ['>=', ['get', 'Longitude'], bounds.getWest()],
                                        ['<=', ['get', 'Longitude'], bounds.getEast()],
                                        ['>=', ['get', 'Latitude'], bounds.getSouth()],
                                        ['<=', ['get', 'Latitude'], bounds.getNorth()]
                                    ]
                                });
                                // Deduplicate features
                                visibleFeatures = [...new Map(visibleFeatures.map(feat => 
                                    [feat.properties.row_number, feat]
                                )).values()];
                            } else {
                                // Fall back to filtering the original geojson for initial load
                                visibleFeatures = geojson.features.filter(feature => {
                                    const [lng, lat] = feature.geometry.coordinates;
                                    return lng >= bounds.getWest() &&
                                           lng <= bounds.getEast() &&
                                           lat >= bounds.getSouth() &&
                                           lat <= bounds.getNorth();
                                });
                            }

                            // Sort features by distance from map center
                            visibleFeatures.sort((a, b) => {
                                const pointA = turf.point(a.geometry.coordinates);
                                const pointB = turf.point(b.geometry.coordinates);
                                const distanceA = turf.distance(origin, pointA);
                                const distanceB = turf.distance(origin, pointB);
                                return distanceA - distanceB;
                            });

                            const sidebar = document.getElementById('sidebar');
                            sidebar.innerHTML = `<h2 class="text-lg font-bold mb-4">Visible Locations (${visibleFeatures.length})</h2>`;
                            
                            visibleFeatures.forEach(feature => {
                                const props = feature.properties;
                                const coords = feature.geometry.coordinates;
                                
                                // Calculate distance
                                const destination = turf.point(coords);
                                const distance = turf.distance(origin, destination, {units: 'kilometers'});
                                const formattedDistance = distance < 1 
                                    ? `${Math.round(distance * 1000)} m` 
                                    : `${Math.round(distance * 10) / 10} km`;

                                // Get direction arrow or dot based on distance
                                const rotatedArrow = distance < 0.01 ? '•' : getDirectionalArrow(turf.bearing(origin, destination));

                                const div = document.createElement('div');
                                div.className = 'mb-4 p-2 bg-gray-100 rounded sidebar-item hover:bg-gray-200 transition-colors duration-150';
                                div.setAttribute('data-lng', props.Longitude);
                                div.setAttribute('data-lat', props.Latitude);
                                div.setAttribute('data-row', props.row_number);
                                
                                // Add hover handlers
                                let hoveredStateId = null;
                                
                                div.addEventListener('mouseenter', () => {
                                    // Remove previous hover state
                                    if (hoveredStateId) {
                                        map.setFeatureState(
                                            { source: 'deals', id: hoveredStateId },
                                            { hover: false }
                                        );
                                    }
                                    
                                    // Add hover state to this feature
                                    hoveredStateId = props.row_number;
                                    map.setFeatureState(
                                        { source: 'deals', id: hoveredStateId },
                                        { hover: true }
                                    );
                                    
                                    // Add hover class to div
                                    div.classList.add('bg-gray-200');
                                });

                                div.addEventListener('mouseleave', () => {
                                    // Remove hover state
                                    if (hoveredStateId) {
                                        map.setFeatureState(
                                            { source: 'deals', id: hoveredStateId },
                                            { hover: false }
                                        );
                                    }
                                    hoveredStateId = null;
                                    
                                    // Remove hover class from div
                                    div.classList.remove('bg-gray-200');
                                });

                                div.innerHTML = `
                                    <div class="flex justify-between items-start">
                                        <h4>${props['name'] || 'N/A'}</h4>
                                        <span class="text-sm text-gray-600">
                                            ${rotatedArrow} ${formattedDistance} away
                                        </span>
                                    </div>
                                    <p>Address: ${props['Address'] || 'N/A'}</p>
                                    <p>Category: ${props['Project Category'] || 'N/A'}</p>
                                    <p>Amount: ${props['Total Amount'] || 'N/A'}</p>
                                `;
                                
                                div.addEventListener('click', () => {
                                    const lng = parseFloat(div.getAttribute('data-lng'));
                                    const lat = parseFloat(div.getAttribute('data-lat'));
                                    if (!isNaN(lng) && !isNaN(lat)) {
                                        map.flyTo({
                                            center: [lng, lat],
                                            zoom: 14
                                        });
                                    }
                                });
                                sidebar.appendChild(div);
                            });
                        }

                        // Update sidebar when map moves
                        map.on('moveend', updateSidebar);

                        map.on('click', 'deals', (e) => {
                            const coordinates = e.features[0].geometry.coordinates.slice();
                            const properties = e.features[0].properties;

                            let popupContent = '<div style="max-height: 300px; overflow-y: auto;"><table class="min-w-full divide-y divide-gray-200 text-xs">';
                            
                            // Add URL to the top if it exists
                            if (properties.url || properties.URL || properties.Url) {
                                const url = properties.url || properties.URL || properties.Url;
                                popupContent += `<tr><td colspan="2" class="px-2 py-1 whitespace-nowrap text-center"><a href="${url}" target="_blank" class="text-blue-500 hover:text-blue-700">View Details</a></td></tr>`;
                            }
                            
                            for (const [key, value] of Object.entries(properties)) {
                                if (key.toLowerCase() !== 'url') {
                                    popupContent += `<tr><td class="px-2 py-1 whitespace-nowrap font-medium text-gray-900">${key}:</td><td class="px-2 py-1 whitespace-nowrap text-gray-500">${value}</td></tr>`;
                                }
                            }
                            popupContent += '</table></div>';

                            new mapboxgl.Popup()
                                .setLngLat(coordinates)
                                .setHTML(popupContent)
                                .addTo(map);
                        });

                        map.on('mouseenter', 'deals', () => {
                            map.getCanvas().style.cursor = 'pointer';
                        });

                        map.on('mouseleave', 'deals', () => {
                            map.getCanvas().style.cursor = '';
                        });

                        // Create filters dynamically
                        const filterContainer = document.getElementById('filterContainer');
                        const fields = Object.keys(data[0]).slice(0, 4);
                        const filters = {};

                        fields.forEach(field => {
                            const values = [...new Set(data.map(item => item[field]))];
                            const select = document.createElement('select');
                            select.id = `${field}Filter`;
                            select.className = 'text-sm border rounded';
                            select.innerHTML = `<option value="">All ${field}</option>`;
                            values.forEach(value => {
                                const option = document.createElement('option');
                                option.value = value;
                                option.textContent = value;
                                select.appendChild(option);
                            });
                            filterContainer.appendChild(select);
                            filters[field] = select;

                            select.addEventListener('change', applyFilters);
                        });

                        function applyFilters() {
                            const filterConditions = Object.entries(filters).map(([field, select]) => {
                                const value = select.value;
                                return value ? ['==', ['get', field], value] : true;
                            });

                            map.setFilter('deals', ['all', ...filterConditions]);
                            updateSidebar();
                        }

                        // Trigger initial sidebar update after layer is added
                        updateSidebar();
                    }
                });
            });
        }

        // Helper function to get the appropriate arrow based on bearing
        function getDirectionalArrow(bearing) {
            // Normalize bearing to 0-360
            bearing = ((bearing + 360) % 360);
            
            // Convert bearing to 8 cardinal/intercardinal directions
            if (bearing >= 337.5 || bearing < 22.5) return '↑';
            if (bearing >= 22.5 && bearing < 67.5) return '↗';
            if (bearing >= 67.5 && bearing < 112.5) return '→';
            if (bearing >= 112.5 && bearing < 157.5) return '↘';
            if (bearing >= 157.5 && bearing < 202.5) return '↓';
            if (bearing >= 202.5 && bearing < 247.5) return '↙';
            if (bearing >= 247.5 && bearing < 292.5) return '←';
            return '↖';
        }

        // Also add hover handlers for map features
        let hoveredStateId = null;

        map.on('mousemove', 'deals', (e) => {
            if (e.features.length > 0) {
                if (hoveredStateId) {
                    map.setFeatureState(
                        { source: 'deals', id: hoveredStateId },
                        { hover: false }
                    );
                }
                hoveredStateId = e.features[0].properties.row_number;
                map.setFeatureState(
                    { source: 'deals', id: hoveredStateId },
                    { hover: true }
                );
                
                // Also highlight the corresponding sidebar item
                const sidebarItem = document.querySelector(`[data-row="${hoveredStateId}"]`);
                if (sidebarItem) {
                    sidebarItem.classList.add('bg-gray-200');
                }
            }
        });

        map.on('mouseleave', 'deals', () => {
            if (hoveredStateId) {
                map.setFeatureState(
                    { source: 'deals', id: hoveredStateId },
                    { hover: false }
                );
                
                // Remove highlight from sidebar item
                const sidebarItem = document.querySelector(`[data-row="${hoveredStateId}"]`);
                if (sidebarItem) {
                    sidebarItem.classList.remove('bg-gray-200');
                }
            }
            hoveredStateId = null;
        });
    </script>
</body>
</html>
